const notesInOctave = 12;
const octaveMod = function(pitch) {
  return ((pitch % notesInOctave) + notesInOctave) % notesInOctave;
}

/**
 * A collection of successive pitches contained within an octave
 */
class PitchCollection {
  /**
   * Creates a new PitchCollection object
   * @param {Array<Numbers>} pitches - a non-empty array of abstract pitches where the difference between
   *    elements corresponds to the distance between the pitches in half-steps. Elements in the array must
   *    be strictly increasing.
   * @throws {Error} if the range of the pitch collection exceeds an octave
   */
  constructor(pitches) {
    let abstractPitches = pitches.map((el, i, arr) => el - arr[0]);

    if (abstractPitches.slice(-1) >= notesInOctave) throw new Error("Range of PitchCollection exceeds an octave!");

    this.getAbstractPitches = function() {
      return abstractPitches.slice();
    }
    this.getNoteQuantity = function() {
      return abstractPitches.length;
    }
  }

  /**
   * Generates a Mode object from this and a given pitch center
   * @param {Number} pitchCenter - a number representing a pitch class where 0 is c, 1 is c-sharp/d-flat, ... , 11 is b 
   * @returns {Mode} - a new Mode object
   */
  createMode(pitchCenter) {
    return new Mode(this.getAbstractPitches(), pitchCenter);
  }

  /**
   * Generates a new mode object from this if all abstract pitch values in Mode align to this with respect to a given 
   *    starting point based on a given scale degree in this. The pitch center of new Mode object will be relative to
   *    the pitch center of Mode offset by the interval dictated by the given scale degree
   * @param {Mode} mode - a Mode object
   * @param {Number} scaleDegree - the scale degree of this that the first pitch in mode should be matched to
   * @returns a new Mode object or undefined if a match is not made
   */
  matchMode(mode, scaleDegree=0) {
    let basePitches = this.getAbstractPitches()
    let offset = basePitches[scaleDegree]
    let modePitchesWithOffset = mode.getAbstractPitches().map(el => el + offset);
    let currentPitch = modePitchesWithOffset.shift();

    for (let el of basePitches) {
      if (el === currentPitch) {
        if (!modePitchesWithOffset.length) return new Mode(basePitches, -offset)
        currentPitch = modePitchesWithOffset.shift();
      } else if (el > currentPitch) return false;
    }

    return false;
  }

  /**
   * Generates an array of all Modes generated by calling matchMode on a Mode object and incrementing through all scale
   *    degrees in this
   * @param {Mode} mode - a Mode object
   * @returns {Array<Mode>} - an array of new Mode objects that match the provided mode
   */
  matchAll(mode) {
    let modeList = []

    this.getAbstractPitches().forEach((el, i) => {
      let match = this.matchMode(mode, i)
      if (match) modeList.push(match);
    })

    return modeList;
  }
}

/**
 * A collection of successive pitches contained within an octave that start at a specific note
 */
class Mode extends PitchCollection {
  /**
   * Creates a new Mode object
   * @param {Array<Numbers>} pitches - a non-empty array of abstract pitches where the difference between
   *    elements corresponds to the distance between the pitches in half-steps. Elements in the array must
   *    be strictly increasing.
   * @param {Number} pitchCenter - a number representing a pitch class where 0 is c, 1 is c-sharp/d-flat, ... , 11 is b
   * @throws {Error} if the range of the pitch collection exceeds an octave
   */
  constructor(pitches, pitchCenter) {
    super(pitches);
    let absolutePitches = this.getAbstractPitches().map(el => octaveMod(pitchCenter) + el);

    this.getAbsolutePitches = function() {
      return absolutePitches.slice()
    }
    this.getPitchCenter = function() {
      return absolutePitches[0];
    }
  }
}

module.exports = {
  PitchCollection: PitchCollection,
  Mode: Mode
}